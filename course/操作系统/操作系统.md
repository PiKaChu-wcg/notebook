# 绪论

<img src="%E5%9B%BE%E7%89%871.jpg" alt="图片1" style="zoom:40%;" />

>   在一个计算机系统中，通常都含有多种硬件和软件资源。归纳起来可将这些资源分为四类：处理机、存储器、I/O设备以及文件(数据和程序)。

## 单道批处理系统

>   为实现对作业的连续处理，需要先把一批作业以脱机方式输入到磁带上，并在系统中配上监督程序(Monitor)，在它的控制下，使这批作业能一个接一个地连续处理。 

<img src="%E5%9B%BE%E7%89%872.jpg" alt="图片2" style="zoom:40%;" />

>   最主要的缺点是，系统中的资源得不到充分的利用。这是因为在内存中仅有一道程序，每逢该程序在运行中发出I/O请求后，CPU便处于等待状态，必须在其I/O完成后才继续运行。

<img src="%E5%9B%BE%E7%89%873.jpg" alt="图片3" style="zoom:40%;" />

## 多道批处理系统

<img src="%E5%9B%BE%E7%89%874.jpg" alt="图片4" style="zoom:50%;" />

**优缺点如下：**

>   **资源利用率高**。引入多道批处理能使多道程序交替运行，以保持CPU处于忙碌状态；在内存中装入多道程序可提高内存的利用率；此外还可以提高I/O设备的利用率。
>
>   **系统吞吐量大**。能提高系统吞吐量的主要原因可归结为：① CPU和其它资源保持“忙碌”状态；② 仅当作业完成时或运行不下去时才进行切换，系统开销小。
>
>   **平均周转时间长**。由于作业要排队依次进行处理，因而作业的周转时间较长，通常需几个小时，甚至几天。
>
>   **无交互能力**。用户一旦把作业提交给系统后，直至作业完成，用户都不能与自己的作业进行交互，修改和调试程序极不方便。

**需要解决的问题**

>   处理机争用问题
>
>   内存分配和保护问题
>
>   I/O设备分配问题
>
>   文件的组织和管理问题
>
>   作业管理问题
>
>   用户与系统的接口问题

## 分时系统

>   多路性,独立性,及时性, 交互性。 

# 进程

## 前驱图

>   前趋图(Precedence Graph)，是指一个**有向无循环图**，可记为DAG(Directed Acyclic Graph)，它用于描述进程之间执行的先后顺序。图中的每个结点可用来表示一个进程或程序段，乃至一条语句，结点间的有向边则表示两个结点之间存在的偏序(Partial Order)或前趋关系(Precedence Relation)。

## 程序的基本状态和转换

唤醒原语**wakeup** :首先把被阻塞的进程从等待该事件的阻塞队列中移出，将其PCB中的现行状态由阻塞改为就绪，然后再将该PCB插入到就绪队列中

阻塞原语**block**:把进程控制块中的现行状态由“执行”改为阻塞，并将PCB插入阻塞队列

### 三状态

<img src="%E5%9B%BE%E7%89%871-1608793912224.jpg" alt="图片1" style="zoom:50%;" />

>   处于就绪状态的进程，在调度程序为之分配了处理机之后便可执行，相应地，其状态就由**就绪**态转变为**执行**态；
>
>   正在**执行**的进程(当前进程)如果因分配给它的时间片已完而被剥夺处理机暂停执行时，其状态便由执行转为**就绪**；
>
>   如果因发生某事件，致使当前进程的**执行**受阻(例如进程访问某临界资源，而该资源正被其它进程访问时)，使之无法继续执行，则该进程状态将由执行转变为**阻塞**。

### 五状态

<img src="%E5%9B%BE%E7%89%872-1608794077918.jpg" alt="图片2" style="zoom:50%;" />

>   **创建状态**:首先由进程申请一个空白PCB，并向PCB中填写用于控制和管理进程的信息；然后为该进程分配运行时所必须的资源；最后，把该进程转入就绪状态并插入就绪队列之中。
>
>   **终止状态**:等待操作系统进行善后处理，最后将其PCB清零，并将PCB空间返还系统。进入终止态的进程以后不能再执行，但在操作系统中依然保留一个记录，其中保存状态码和一些计时统计数据，供其他进程收集。

### 七状态

<img src="%E5%9B%BE%E7%89%873-1608794244100.jpg" alt="图片3" style="zoom:50%;" />

## PCB

>   OS管理的这些数据结构一般分为以下四类：内存表、设备表、文件表和用于进程管理的进程表，通常进程表又被称为进程控制块PCB。 

<img src="%E5%9B%BE%E7%89%874-1608794426623.jpg" alt="图片4" style="zoom:50%;" />

**进程控制块PCB的作用**

>    作为独立运行基本单位的标志。
>
>    能实现间断性运行方式。 
>
>   提供进程管理所需要的信息。
>
>   提供进程调度所需要的信息。
>
>    实现与其它进程的同步与通信。

## 临界

**临界资源**，诸进程间应采取互斥方式，实现对这种资源的共享

每个进程中访问临界资源的那段代码称为**临界区**(critical section)

## ==PV操作==

**wait(S)**和**signal(S)**,分别被称作**P,V**操作

### 信号量

整型信号量

```c++
int S=1;
void wait(int S){
    while(S<=-);
    S=S-1;
}
void signal(S){
    S=S+1;
}
```

记录性型信号量

```c++
typedef struct{
    int value;
    struct process *L;
}  semaphore;
void wait(semaphore S){
    S.value--;
    if(S.value<0){
        block(S.L);
    }    
}
void signal(semaphore S){
    S.value++;
    if(S.value<=0){
        wakeup(S.L);
    }
}
```

### 互斥访问

```c++
semaphore mutex=1;
void p1(){
    P(mutex);
    临界区代码
    V(mutex);
}
```

### 生产者消费者

```c++
semaphore mutex=1;
semaphore empty=n;
semaphore full=0;
void producer(){
    while(1){
        P(empty);
        P(mutex);
        
        V(mutex);
        V(full);
    }
}
void consumer(){
    while(1){
        P(full);
        P(mutex);
        
        V(mutex);
        V(empty);
    }
}   
//P操作的顺序不能交换
```



## ==进程调度==

周转时间=完成时间-到达时间

带权周转时间=周转时间/运行时间

等待时间=周转时间-运行时间

FCFS,SJF,SRTN,HRRN($响应比=\frac{等待时间+要求服务时间}{要求服务时间}$)

RR

# 处理机调度

## ==银行家算法==

可利用资源向量Available。

最大需求矩阵Max。

分配矩阵Allocation。

需求矩阵Need。



(1) 如果Request i[j]≤Need[i, j]，便转向步骤(2)； 否则认为出错，因为它所需要的资源数已超过它所宣布的最大值。
 　(2) 如果Request i[j]≤Available[j]，便转向步骤(3)； 否则，表示尚无足够资源，Pi须等待。

(3) 系统试探着把资源分配给进程Pi，并修改下面数据结构中的数值：
    　Available[j] = Available[j] - Request i[j];
  　Allocation[i, j] = Allocation[i, j] + Request i[j];
  　　Need[i, j] = Need[i, j] - Request i[j];
 　(4) 系统执行安全性算法，检查此次资源分配后系统是否处于安全状态。若安全，才正式将资源分配给进程Pi，以完成本次分配；否则，将本次的试探分配作废，恢复原来的资源分配状态，让进程Pi等待。

# 存储器

## ==地址变换==

![图片1](%E5%9B%BE%E7%89%871.png)

# 虚拟存储

## ==页面置换==

# 输入输出

## ==磁盘调度==

# 文件管理

#  磁盘管理